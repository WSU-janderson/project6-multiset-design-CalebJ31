Introduction
    - My design will model a player inventory system that uses a HashTable<string, int>. I have chosen this data 
    structure to model my game system because a HashTable is able to store an item(string) and also keep count(int) 
    of how many of this item that we have in our inventory. The reason this is the best data structure to use is
    simply because of the ability to store the number(count) of a certain item that we have. Using a HashTable for
    our game system will be helpful because knowing how many of an item is extremely important, one example of
    it's importantance is crafting items, certain items may require a certain amount of different items in order
    to craft the item.
Design Philosophy 
-Efficiency 
   	 -For my MultiSet implementation, I wanted to prioritize speed in my design. Speed is a huge focus of 
     all modern games; players want to be able to play a game that runs smoothly and gives seemingly instantaneous 
     feedback. For this exact reason, this is the main reasoning behind why the HashTable is an efficient choice 
     for a multiSet implementation. Most operations of the HashTable are constant time, which is perfect for what 
     I want to achieve speed-wise for the game. We can add more instances of an element without allocating extra 
     memory for duplicates.

-Simplicity
 Our Hash Table exemplifies simplicity; we are able to use the string to store the name of the item, then use the 
 int stored in to represent how many occurrences/instances we have of that specific item. This data structure is 
 also very intuitive in how it works, the client can easily see the intention of storing the object name as a 
 string, and then using the int to keep track of the number of occurrences for that element.
 Extensibility
	The Hash Table is easily extensible. This is perfect for games in this age, as they are constantly adding 
    features to their architecture. The core operations of the HashTable allow us to add a multitude of things 
    such as merging inventories, managing player stats, or even managing card games.



Readability
	HashTables are great for readability. The use of our key-value pairs is evidently clear that the key is the 
    name of the item, and the value is the number of that item. Other operations like the insert or remove 
    function, further demonstrate this readability


Core Operations
Every MultiSet should have 5 essential operations: an insert function, remove function, count function, 
and a contains function

Insert Function:
    -What it does conceptually in your chosen game scenario: 
	In my chosen game scenario, the insert function is responsible for adding items(key) into our player's 
    inventory. In addition to adding the item(key), the insert function must also add the number of instances. 
    This function can be used to accumulate items that may already be in the table, and update the value to 
    indicate how many of the items the player has in the inventory.
    • Its expected time complexity:
	The insert function has O(1) average time. This function simply inserts the key if it is not in the MultiSet; 
    if it is, then it will increment the value.
    • Possible edge cases or exceptional situations:
Inserting a key with an empty name
    • How your underlying data structure supports or constrains the operation:
	The HashTable data structure supports this operation well. The structure of a HashTable using key-value pairs 
    is perfect for what I want to achieve. If a key does not yet exist, the operation simply inserts the key with 
    a value of 1. If the key does exist, the value is incremented. We are able to have direct access, skipping the 
    need to look through all the keys, which can make our insertion near instantaneous.

Remove Function:
 -What it does conceptually in your chosen game scenario: 
In the selected game scenario, the remove function will decrement the value if the item already 
exists in the table. Further, if there is more than one of the item, the function will remove one of the 
items from the value. If no more of the item exists, or more simply put, if the value is 0, the item will 
be removed from the inventory. For example, if a player shoots arrows, every time an arrow is fired, 
the player must lose an arrow from their inventory, and if they run out of arrows, the item must 
disappear from the inventory 
 • Its expected time complexity:
	This function is expected to have O(1) average time complexity.
  • Possible edge cases or exceptional situations:
Count is already 0, in this case we do not want the player to have negative items, the player should simply run out, so no removal should be performed.
Removing more than the player has. Similar to the last case, we do not want the player to have negative items; 
therefore, no removal will be performed due to insufficient funds, so to speak.
Removal of an item that does not exist. A player should not lose an item they do not have in their inventory
 • How your underlying data structure supports or constrains the operation:
	The use of a HashTable supports this operation because of quick access checking, the value can easily be 
    retrieved and either decremented if it is greater than zero otherwise, if it is equal to zero, the key can 
    be deleted, which helps free up memory after the item is completely gone.
 
Count Function:
	 -What it does conceptually in your chosen game scenario: 
		- The count function will provide the user with how many occurrences they have of a certain item. 
        This function is important because it can be used for crafting purposes. If a player does not have
         enough of an item, they are not able to craft another item.
	 • Its expected time complexity:
		Simply O(1) time. This function is just retrieving the value stored with the associated key.
 • Possible edge cases or exceptional situations:
- Getting the value associated with a key that does not exist. In this case, just return zero.
	 • How your underlying data structure supports or constrains the operation:
		The HashTable supports this operation because of its key-value setup. Since we are storing the count in 
        the value, we can return, value as how many we have. The HashTable also makes this extremely efficient 
        because the value is already stored. If a LinkedList were to be used, each element would have to be checked. If an AVL tree were used, duplicates would lead to a very complicated process. The HashTable is by far the best for the count function.

Contains function:
	 -What it does conceptually in your chosen game scenario: 
		In my game scenario, the contains function will be used to see if an element exists in the player's inventory. This function can allow a player to use a door if they have a key in their inventory, or even craft items if they have the required items in their inventory
	 • Its expected time complexity:
		Expected time complexity is O(1). This function just checks if the key exists or not.
	 • Possible edge cases or exceptional situations: N/A
	 • How your underlying data structure supports or constrains the operation:
	   A HashTable supports this operation well, since this operation only cares if the key exists, so we are 
       just checking for that. This function is also extremely quick and efficient.


Set Operations

Extension Feature
UML Diagram/ Abstraction Boundary
Trade-Off Analysis
Alternitive Design Sketch
Evaluation Plan
Conclusion/Reflection